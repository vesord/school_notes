# Утечка памяти

## Что такое?

### Выделение памяти

Когда мы работаем с данными неопределенного размера (массивы, строки и т.п.) мы выделяем под них динамическую память.
Обычно это происходит с помощью команды `malloc()`.
Маллок возвращает указатель на память, которую он выделил `void*`, и мы записываем этот указатель в переменную.
Теперь мы можем читать/записывать по этому адресу (который лежит в переменной) выделенное количество байт.

В примере ниже мы выделяем память под 20 чаров, как-то с ней работаем и выходим из программы, предворительно освободив выделенное.

```C
#include <stdlib.h>
#include <unistd.h>

int main()
{
    char *str;
    
    str = malloc(sizeof(*str) * 20);        // выделение 20 байт памяти под строку
                                            // теперь в str лежит указатель на эту память
                                     
    *str = 'a';                             // *str - значение первого (нулевого) байта из этой памяти
    *(str + 3) = 'd';                       // *(str + 3) - значение четвертого (третьего) байта и т.д.
                                            // N.B. запись *(str + 3) эквивалентна str[3]
    
    free(str);                              // освобождаем память
    
    return (0);
}

```

### Утечка памяти

Утечка памяти происходит в тот момент, когда мы **теряем возможность** освободить то, что было выделенно.

В примере ниже мы просто меняем значение переменной str, то есть навсегда теряем адрес памяти, которая была выделена.

```C
#include <stdlib.h>
#include <unistd.h>

int main()
{
    char *str;
    
    str = malloc(sizeof(*str) * 20);        // выделение 20 байт памяти под строку
                                            // теперь в str лежит указатель на эту память
                                     
    *str = 'a';                             // *str - значение первого (нулевого) байта из этой памяти
    *(str + 3) = 'd';                       // *(str + 3) - значение четвертого (третьего) байта и т.д.
                                            // N.B. запись *(str + 3) эквивалентна str[3]
                                            
    str = NULL;                             // утечка тут                                        
    
    free(str);                              // free() не выдает ошибку при аргументе NULL
    
    return (0);
}

```

## Почему это плохо?

Представим ситуацию: вы написали компьютерную игру с утечками в какой-то функции, например в `ft_strjoin()`. Каждый раз при вызове этой функции программа будет увеличивать количество памяти, которую она потребляет (можно посмотреть сколько памяти выделено под каждый запущенный процесс командой `top`). Указатели на выделяемую память теряются, эта память не фришится, и в какой-то момент операционная система говорит "Мои ресурсы закончились". `malloc()` возвращает `NULL`, ваша программа понимает (надеюсь, вы написали защиту для маллока\*), что что-то идет не так и завершает свою работу с каким-то кодом ошибки.

Я слышал много мнений о том, что утекшая память - это не освобождённая ( `free()` ) память. Это верно, но есть нюансы. 
