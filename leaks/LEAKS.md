# Утечка памяти

## Что такое?

### Выделение памяти

Когда мы работаем с данными неопределенного размера (массивы, строки и т.п.) мы выделяем под них динамическую память.
Обычно это происходит с помощью команды `malloc()`.
Маллок возвращает указатель на память, которую он выделил `void*`, и мы записываем этот указатель в переменную.
Теперь мы можем читать/записывать по этому адресу (который лежит в переменной) выделенное количество байт.

В примере ниже мы выделяем память под 20 чаров, как-то с ней работаем и выходим из программы, предворительно освободив выделенное.

```C
#include <stdlib.h>
#include <unistd.h>

int main()
{
    char *str;
    
    str = malloc(sizeof(*str) * 20);        // выделение 20 байт памяти под строку
                                            // теперь в str лежит указатель на эту память
                                     
    *str = 'a';                             // *str - значение первого (нулевого) байта из этой памяти
    *(str + 3) = 'd';                       // *(str + 3) - значение четвертого (третьего) байта и т.д.
                                            // N.B. запись *(str + 3) эквивалентна str[3]
    
    free(str);                              // освобождаем память
    
    return (0);
}

```

### Утечка памяти

Утечка памяти происходит в тот момент, когда мы **теряем возможность** освободить то, что было выделенно.

В примере ниже мы просто меняем значение переменной str, то есть навсегда теряем адрес памяти, которая была выделена.

```C
#include <stdlib.h>
#include <unistd.h>

int main()
{
    char *str;
    
    str = malloc(sizeof(*str) * 20);        // выделение 20 байт памяти под строку
                                            // теперь в str лежит указатель на эту память
                                     
    *str = 'a';                             // *str - значение первого (нулевого) байта из этой памяти
    *(str + 3) = 'd';                       // *(str + 3) - значение четвертого (третьего) байта и т.д.
                                            // N.B. запись *(str + 3) эквивалентна str[3]
                                            
    str = NULL;                             // утечка тут, мы потеряли выделенный malloc'ом адрес
    
    free(str);                              // free() не выдает ошибку при аргументе NULL
    
    return (0);
}

```

## Почему это плохо?

Представим ситуацию: вы написали компьютерную игру с утечками в какой-то функции, например в `ft_strjoin()`. Каждый раз при вызове этой функции программа будет увеличивать количество памяти, которую она потребляет (можно посмотреть сколько памяти выделено под каждый запущенный процесс командой `top`). Указатели на выделяемую память теряются, эта память не фришится, и в какой-то момент операционная система говорит "Мои ресурсы закончились". `malloc()` возвращает `NULL`, ваша программа понимает (надеюсь, вы написали защиту для маллока\*), что что-то идет не так и завершает свою работу с каким-то кодом ошибки. Пользователь в недоумении, почему у него вылетела игра в самый ответственный момент.

## Как искать лики?

В целом школьных маках можно использовать 2 программы для поиска утечек: `valgrind` и `leaks`

### valgrind

[Гайд по установке](https://github.com/daniiomir/faq_for_school_21#%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-valgrind-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0-%D1%83%D1%82%D0%B5%D1%87%D0%B5%D0%BA)

* Шаг 1: скомпилировать свою программу с флагом `-g`

При этом в текущей директории появятся дополнительный каталог, после проверки на утечки его можно будет удалить (и убрать флаг `-g` из мейкфайла)

<div>
  <img src="./imgs/leaks_step1.png" width="200">
</div>
<br>

* Шаг 2: запустить `valgrind` передав ему в аргументы вашу программу (`a.out`)

Валгринд запустит вашу программу и после её завершения предоставит отчёт о её работе. Нас интересует строка `defenetly lost` (красный). Валгринд говорит нам, что у нас утекло 20 байт (как неожиданно!).

<div>
  <img src="./imgs/leaks_step2.png" width="200">
</div>
<br>

* Шаг 3: перезапустить `valgrind` с флагом `--leak-check=full`.

Если забыли флаг, он всегда показывается при обычном выводе валгринда (синий на предыдущем скриншоте).

Сейчас главное не испугаться ОГРОМНОГО ВЫВОДА ВСЕГО ЧТО НАШЕЛ VALGRIND :) (о том, что он там еще находит будет написано ниже)

<div>
  <img src="./imgs/leaks_step3.png" width="200">
</div>
<br>

В каждом блоке найденной ошибки валгринд показывает стек вызова функций (функции, которые мы вызывали в обратном порядке). Если то что там написано вообще не имеет отношения к тому, что вы писали в своей программе - забудьте об этом. Валгринд погавкал на прохожих.

* Шаг 4: найти место где утекло именно у вас

В примере видно, что в функции `main` был вызван `malloc`. Утекла именно та память, которую выделил этот маллок.

Я слышал много мнений о том, что утекшая память - это не освобождённая ( `free()` ) память. Это верно, но есть нюансы. 
