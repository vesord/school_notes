# Как понять, что значит указатель?

## Напоминалка

Напомню, что указатель - это **переменная**, в которой хранится **адрес** ячейки памяти, в которой что-то лежит.

Адрес - это специальный тип (типы) данных, такие же как int, char, и т.п.

```C
char    s1  // тип char
char *  s2  // тип указатель (адрес) на char
char ** s3  // тип указатель (адрес) на указатель (адрес) на char
```

Чтобы получить адрес какой-либо переменной необходимо перед именем этой переменной написать символ `&`

```C
int a    = 21;    // число 21 (переменная а) хранится где-то в памяти
int *ptr = &a;    // теперь в ptr хранится адрес переменной а (числа 21)
```

Чтобы получить значение переменной, которая хранится по какому-то адресу, необходимо к переменной типа адрес приписать `*`

```C
int a    = 21;
int *ptr = &a;

int b    = *ptr;  // в переменную b записалось значение, которое лежало в памяти по адресу, который хранился в ptr
```

Переменные с типом "адрес" (указатели) явяются обычными переменными, мы можем записывать в них информацию.


```C
size_t *ptr = 453;   // так делать законно, в переменной ptr хранится число 453

size_t b    = *ptr;  // скорее всего segmentation fault
```

С помощью указателей (адресов какого-то места в памяти) можно передавать между разными частями программы некоторые структуры данных 
(строки, связные списки и т.п.) а тажке избежать лишнего копирования больших структур данных (большие структуры, массивы и т.п.).

## Понять звёздочки?

Допустим, наша функция принимает указатель на указатель на char. Её прототип:

```C
void foo(char **ch);
```

Под `char **ch` будем понимать адрес начала строки.

Что нужно написать, чтобы изменить первый символ этой строки?
Чтобы изменить строку полностью?
Как передать адрес строки в другую функцию? Символ? Адрес адреса строки? Адрес адреса символа?

КАК НЕ ЗАПУТАТЬСЯ В ЗВЁЗДОЧКАХ???

Всё просто. Нужно посмотреть на **тип** переменной, которая у нас есть и закрыть пальцем (можно в уме) тип и нужное количество звёздочек.

Изменим первый символ строки. Мы точно знаем, что символ - это тип `char`, поэтому "закрываем" char: 

~~char~~ \*\*ch

```C
**ch = 'k';    // записали в первый символ строки 'k'
```

Изменим саму строку (например, старую нам нужно зафришить, а на новую выделить память). Строка - это тип `char *`, "закрываем" char \*:

~~char \*~~ \*ch

```C
free(*ch);               // зафришили строку
...
*ch = malloc(100500);    // выделили ей новую память
...
(*ch)[100500] = '\0';    // как-то модифицировали строку
...
do_smth(*ch);            // отправили её в другую функцию
```

Нетрудно догадаться как передать адрес адреса строки в другую функцию. Адрес адреса строки - это `char **`, поэтому:

~~char \*\*~~ ch

```C
free_tab(ch);         // оправили массив строк (если это был массив строк) фришиться
```

Надеюсь, этот способ упростит вам указательную жизнь. Возможно вы уже и так мастер. В любом случае, если что-то не ясно, или я где-то оишбся - пишите ;)


