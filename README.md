# Структуры в Си

## Что такое?

Структура - это абстракция над переменными. Условный "мешок" в котором может храниться несколько переменных.
Как и у обычной переменной у структуры есть свой тип и имя.

```C
Тип_переменной     Имя_переменной

int                fd;
_тип_структуры_    gnl_struct;
```

## Как создать структуру?

Поскольку Си не знает заранее, какие структуры мы хотим использовать, то нам нужно их определить.

```C
#include "my_super_header.h"

struct s_gnl_struct
{
    int   fd;
    int	  last_readed;
    char  unicorn;
};

int main()
...
```

Теперь компилятор в Си знает, что есть **тип данных** `struct s_gnl_struct` и поэтому его можно использовать.

## Пример использования

```C
    ...
    
int main()
{
    struct s_gnl_struct a;

    a.fd = 3;
    a.last_readed = 43;
    a.unicorn = 'U';

    printf("%d, %d, %c\n", a.fd, a.last_readed, a.unicorn);

    return 0;
}
```

В примере мы создали "мешок с переменными" который имеет **тип** `struct s_gnl_struct` и **имя** `a`
Обращения к содержимому "мешка" происходит через "."

## Расположение в памяти

Любая переменная в вашей программе занимает какое-то место в памяти. Например int - 4 байта, size_t - 8, char - 1 и т.д.

Сколько места в памяти занимает структура?

Очевидно, что как минимум столько, сколько занимают все переменные из структуры. Для нашего примера int + int + char = 4 + 4 + 1, то есть как минимум 9 байт (на самом деле 12).

**Больше примеров**

int, size_t, char где-то в памяти компьютера:


![Имя изображения](./imgs/vars_in_memory)


s_gnl_struct где-то в памяти:


![Имя изображения](./imgs/vars_in_memory)


Причина, почему под char выделяется 4 байта (**ТАК БЫВАЕТ НЕ ВСЕГДА**) - тема отдельного топика. Можно погуглить _padding in memory_, например вот [хорошая статья про выравнивание структур в Си](https://fresh2refresh.com/c-programming/c-structure-padding/#:~:text=In%20order%20to%20align%20the,concept%20is%20called%20structure%20padding.)

## А где typedef?

typedef - это просто слово для объявления **пользовательского** (то есть нашего собственного) типа. Чтобы при объявлении структур не писать много раз 

```C
struct s_gnl_struct b;

struct s_gnl_struct other;
```

можно при объявлении структуры написать

```C
#include "my_super_header.h"

typedef struct  s_gnl_struct
{
    int   fd;
    int   last_readed;
    char  unicorn;
}               t_gnl;

int main()
...
```

теперь вместо огромного и плохо читаемого `struct s_gnl_struct other;` можно писать `t_gnl other;`

```C
int main()
{
    t_gnl a;
  ...
}
```

## Напоминалка про динамическое выделение

Как и все другие переменные структуру можно просто создать (в стековой памяти):

```C
int main()
{
    t_gnl a;
  
    a.fd = 123;
  ...
}
```

так и создать в динамической памяти, и обращаться к ней через указатель:

```C
int main()
{
    t_gnl *ptr_to_struct;
    ptr_to_struct = malloc(sizeof *ptr_to_struct); // Не забывайте ставить * !
  
    (*ptr_to_struct).fd = 321;
    ...
}
```

Здесь мы выделили динамическую память, чтобы в ней лежала наша структура, и присвоили указатель на эту память (то что вернул malloc() ) в переменную указателя на структуру.

## Магическая ->

Обращаться к полям структуры можно все ещё через ".", но необходимо написать много лишних символов. "\*" для разыменования указателя, "( )" для указания приоритета операций, и только потом "."! И всё это слева и справа от имени указателя на структуру.

_Для упрощения жизни_ придумали оператор "->" который позволяет **через указатель** на структуру обратиться к её полям.

```C
int main()
{
    t_gnl *ptr_to_struct;
    ptr_to_struct = malloc(sizeof *ptr_to_struct); // Не забывайте ставить * !
  
    ptr_to_struct->fd = 321;
    ...
}
```

P.S. Если забыть поставить \*, то вместо N байт, которые нужны нам для структуры выделится 8 байт ( размер указателя ). Эту ошибка приводит к трудно воспроизводимым segmentation fault, и долгим часам дебага программы на Си.

## Где применять

Структуры хорошо использовать там, где требуется хранить много связанных по смыслу переменных в одном месте. Относительно школьных проектов, например - это значения спецификаторов формата в ft_printf, структура хранящая информацию о последнем считывании в get_next_line, или структура структур, которая хранит всю информацию об игре cub3D.
